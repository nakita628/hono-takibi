import { DetailedError } from 'hono/client'
import { testClient } from 'hono/testing'
import { describe, expect, it } from 'vitest'
import { app } from './server'

// Re-create client for testing context
const client = testClient(app)

// Import the generated RPC functions and test their behavior
// Note: We can't directly import from generated-rpc.ts because it uses the real client
// Instead, we replicate the pattern here to verify the generated code works correctly
import { parseResponse } from 'hono/client'

/**
 * Tests for generated RPC client functions with parseResponse: true
 *
 * These tests verify that the code generated by hono-takibi with parseResponse: true
 * behaves correctly at runtime.
 */
describe('generated-rpc (parseResponse: true)', () => {
  describe('GET operations without args', () => {
    it('getJson returns parsed JSON', async () => {
      const result = await parseResponse(client.json.$get(undefined, undefined))

      expect(result).toStrictEqual({
        message: 'Hello, World!',
        timestamp: expect.any(Number),
      })
    })

    it('getJsonArray returns parsed array', async () => {
      const result = await parseResponse(client['json-array'].$get(undefined, undefined))

      expect(result).toStrictEqual([{ id: 1 }, { id: 2 }, { id: 3 }])
    })

    it('getText returns parsed text', async () => {
      const result = await parseResponse(client.text.$get(undefined, undefined))

      expect(result).toBe('Plain text response')
    })

    it('getEmpty returns undefined for 204', async () => {
      const result = await parseResponse(client.empty.$get(undefined, undefined))

      expect(result).toBeUndefined()
    })

    it('getNested returns nested object', async () => {
      const result = await parseResponse(client.nested.$get(undefined, undefined))

      expect(result).toStrictEqual({
        user: {
          id: 1,
          name: 'John',
          profile: {
            email: 'john@example.com',
            settings: {
              theme: 'dark',
              notifications: true,
            },
          },
        },
      })
    })

    it('getHeaders returns data (headers are handled by response)', async () => {
      const result = await parseResponse(client.headers.$get(undefined, undefined))

      expect(result).toStrictEqual({ hasHeaders: true })
    })
  })

  describe('mutation operations with args', () => {
    it('postCreate works with json body', async () => {
      const result = await parseResponse(
        client.create.$post({
          json: { name: 'Test Item' },
        }),
      )

      expect(result).toStrictEqual({
        id: 1,
        name: 'Test Item',
        created: true,
      })
    })

    it('putUpdateId works with path param and json body', async () => {
      const result = await parseResponse(
        client.update[':id'].$put({
          param: { id: '42' },
          // biome-ignore lint/suspicious/noExplicitAny: testing runtime behavior
          json: { name: 'Updated Item' } as any,
        }),
      )

      expect(result).toStrictEqual({
        id: 42,
        name: 'Updated Item',
        updated: true,
      })
    })

    it('deleteDeleteId returns undefined for 204', async () => {
      const result = await parseResponse(
        client.delete[':id'].$delete({
          param: { id: '1' },
        }),
      )

      expect(result).toBeUndefined()
    })
  })

  describe('error handling', () => {
    it('getError400 throws DetailedError', async () => {
      await expect(
        parseResponse(client['error-400'].$get(undefined, undefined)),
      ).rejects.toThrow()

      try {
        await parseResponse(client['error-400'].$get(undefined, undefined))
      } catch (e) {
        expect(e).toBeInstanceOf(DetailedError)
        const error = e as DetailedError
        expect(error.statusCode).toBe(400)
      }
    })

    it('getError404 throws DetailedError', async () => {
      await expect(
        parseResponse(client['error-404'].$get(undefined, undefined)),
      ).rejects.toThrow()

      try {
        await parseResponse(client['error-404'].$get(undefined, undefined))
      } catch (e) {
        expect(e).toBeInstanceOf(DetailedError)
        const error = e as DetailedError
        expect(error.statusCode).toBe(404)
      }
    })

    it('getError500 throws DetailedError', async () => {
      await expect(
        parseResponse(client['error-500'].$get(undefined, undefined)),
      ).rejects.toThrow()

      try {
        await parseResponse(client['error-500'].$get(undefined, undefined))
      } catch (e) {
        expect(e).toBeInstanceOf(DetailedError)
        const error = e as DetailedError
        expect(error.statusCode).toBe(500)
      }
    })
  })

  describe('type inference verification', () => {
    it('parseResponse correctly infers return type', async () => {
      // This test verifies that TypeScript correctly infers types
      // The actual runtime behavior is tested above
      const jsonResult = await parseResponse(client.json.$get(undefined, undefined))

      // Type should be inferred from the response
      // @ts-expect-error - Accessing non-existent property should fail
      const _invalid: typeof jsonResult.nonExistent = undefined
      void _invalid

      // Valid access should work
      const message: string = jsonResult.message
      expect(message).toBe('Hello, World!')
    })
  })
})
